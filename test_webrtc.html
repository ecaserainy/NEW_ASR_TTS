<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <title>WebRTC å…¨é“¾è·¯è¯­éŸ³æµ‹è¯•</title>
  <style>
    body { font-family: sans-serif; padding: 1rem; }
    button { margin-right: .5rem; }
    #log { white-space: pre-wrap; background: #f0f0f0; padding: .5rem; height: 150px; overflow: auto; margin-top: .5rem; }
    #messages { background: #eef; padding: .5rem; min-height: 50px; margin-top: .5rem; }
  </style>
</head>
<body>
  <h1>WebRTC å…¨é“¾è·¯è¯­éŸ³æµ‹è¯•</h1>
  <button id="startBtn">å¼€å§‹</button>
  <button id="stopBtn" disabled>åœæ­¢</button>

  <h3>è¿œç«¯æ’­æ”¾ï¼š</h3>
  <audio id="remoteAudio" controls autoplay></audio>

  <h3>è¯†åˆ« & å›å¤ï¼š</h3>
  <div id="messages"></div>

  <h3>æµç¨‹æ—¥å¿—ï¼š</h3>
  <div id="log"></div>

  <script>
    const logEl = document.getElementById('log');
    function log(msg) {
      console.log(msg);
      logEl.textContent += msg + '\n';
      logEl.scrollTop = logEl.scrollHeight;
    }

    const messagesEl = document.getElementById('messages');
    function appendMessage(cls, text) {
      const div = document.createElement('div');
      div.className = cls;
      div.textContent = text;
      messagesEl.appendChild(div);
      messagesEl.scrollTop = messagesEl.scrollHeight;
    }

    let pc, ws, localStream;
    let pingInterval;

    document.getElementById('startBtn').onclick = async () => {
      document.getElementById('startBtn').disabled = true;
      document.getElementById('stopBtn').disabled = false;
      log('ğŸ‘‰ ç‚¹å‡»å¼€å§‹');

      // 1. WebSocket ä¿¡ä»¤
      ws = new WebSocket("wss://192.168.112.66:8443/wss/audio");
      ws.onopen = () => {
        log('âœ… WebSocket å·²è¿æ¥');
        // å¿ƒè·³ä¿æ´»
        pingInterval = setInterval(() => {
          ws.send(JSON.stringify({ action: 'ping' }));
        }, 10000);
        negotiate();
      };
      ws.onerror = e => log('âŒ WebSocket é”™è¯¯: ' + e);
      ws.onclose = () => {
        log('âŒ WebSocket å·²å…³é—­');
        clearInterval(pingInterval);
      };
      ws.onmessage = async evt => {
        // å¤„ç† JSON ä¿¡ä»¤æˆ– ASR/TTS
        let data;
        try { data = JSON.parse(evt.data); }
        catch { return; }

        // æ–‡å­—è¯†åˆ«
        if (data.text && !data.tts_audio) {
          appendMessage('asr', `è¯†åˆ«ï¼š${data.text}`);
        }
        // TTS æ–‡æœ¬
        if (data.tts_audio) {
          appendMessage('tts', `å›å¤ï¼š${data.text}`);
          // å¯é€‰ï¼šè§£ç å¹¶æ’­æ”¾ WebSocket ä¸‹å‘çš„ PCM
          const raw = data.tts_audio.split(',')[1];
          const buf = Uint8Array.from(atob(raw), c=>c.charCodeAt(0)).buffer;
          const ctx = new AudioContext();
          ctx.decodeAudioData(buf, decoded => {
            const src = ctx.createBufferSource();
            src.buffer = decoded;
            src.connect(ctx.destination);
            src.start();
            log('ğŸ”Š WebSocket TTS æ’­æ”¾');
          }, e=>console.error(e));
        }
        // SDP answer
        if (data.answer) {
          log('â¬…ï¸ æ”¶åˆ° SDP answer');
          await pc.setRemoteDescription({ type: 'answer', sdp: data.answer });
          log('âœ… å·²è®¾ç½®è¿œç«¯æè¿° (answer)');
        }
        // ICE candidate from server
        if (data.candidate) {
          log('â¬…ï¸ æ”¶åˆ°è¿œç«¯ ICE candidate');
          try { await pc.addIceCandidate(data.candidate); }
          catch(e){ log('âš ï¸ addIceCandidate å¤±è´¥: '+e); }
        }
      };

      // 2. å‘èµ· WebRTC åå•†
      async function negotiate() {
        pc = new RTCPeerConnection({
          iceServers: [{ urls: 'stuns:stun.l.google.com:19302' }]
        });
        pc.oniceconnectionstatechange = () =>
          log(`ICE çŠ¶æ€: ${pc.iceConnectionState}`);

        // 2.1 è®¢é˜…è¿œç«¯ TTS è½¨å¹¶æ’­æ”¾
        pc.ontrack = event => {
          const audioEl = document.getElementById('remoteAudio');
          if (!audioEl.srcObject) {
            audioEl.srcObject = event.streams[0];
            log('ğŸ§ å·²è®¢é˜…è¿œç«¯ TTS éŸ³è½¨');
          }
        };

        // 3. è·å–éº¦å…‹é£
        try {
          localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
          log('ğŸ¤ å·²è·å–éº¦å…‹é£');
        } catch (e) {
          log('âŒ è·å–éº¦å…‹é£å¤±è´¥: ' + e);
          return;
        }

        // 4. æ¨é€æœ¬åœ°éº¦å…‹é£è½¨
        localStream.getAudioTracks().forEach(track => {
          pc.addTrack(track, localStream);
          log('ğŸ“¤ æ·»åŠ æœ¬åœ°éŸ³è½¨');
        });

        // 5. æ”¶é›†æœ¬åœ° ICE candidate
        pc.onicecandidate = ({ candidate }) => {
          if (candidate) {
            log('â¡ï¸ æœ¬åœ° ICE candidate');
            ws.send(JSON.stringify({ candidate }));
          }
        };

        // 6. åˆ›å»ºå¹¶å‘é€ offer
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
        log('â¡ï¸ å‘é€ SDP offer');
        ws.send(JSON.stringify({ offer: offer.sdp }));
      }
    };

    document.getElementById('stopBtn').onclick = () => {
      ws && ws.close();
      pc && pc.close();
      localStream && localStream.getTracks().forEach(t=>t.stop());
      clearInterval(pingInterval);
      log('â¹ï¸ å·²åœæ­¢');
      document.getElementById('startBtn').disabled = false;
      document.getElementById('stopBtn').disabled = true;
    };
  </script>
</body>
</html>
